package main

import (
	"bytes"
	"encoding/json"
	"fmt"                       // пакет для форматированного ввода вывода
	"github.com/streadway/amqp" //rabbitmq
	"io/ioutil"
	"os"
	//"io/ioutil"
	"log"      // пакет для логирования
	"net/http" // пакет для поддержки HTTP протокола
	"strings"  // пакет для работы с  UTF-8 строками

	_ "github.com/lib/pq"
)

func failOnError(err error, msg string) {
	if err != nil {
		log.Fatalf("%s: %s", msg, err)
	}
}

//noinspection GoFunctionCall
func HomeRouterHandler(w http.ResponseWriter, r *http.Request) {
	Body,err := ioutil.ReadAll(r.Body)
	//Message :=  json.RawMessage(Body)

	connection, err := amqp.Dial(os.Getenv("AMQP_URL"))//соединение с rabbit mq


	fmt.Println("key[%s] value[%s]\n", connection, err)

	//json_map := make(map[string]interface{})		//объявление json как интерфейса для возможности запихать в него все все

	//err = dec.Decode(&json_map)

	type AutoGenerated struct {
		Two0180524142400 struct {
			Name    string      `json:"name"`
			Age     int         `json:"age"`
			Married bool        `json:"married"`
			Dog     interface{} `json:"dog"`
		} `json:"2018-05-24 14:24:00"`
	}
	var utoGenerated  AutoGenerated

	//  json text
	err = json.Unmarshal(Body, &utoGenerated)
	reqBodyBytes := new(bytes.Buffer)
	json.NewEncoder(reqBodyBytes).Encode(utoGenerated)

	//type test interface{}
	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	failOnError(err, "Failed to connect to RabbitMQ")
	defer conn.Close()

	ch, err := conn.Channel()
	failOnError(err, "Failed to open a channel")
	defer ch.Close()

	q, err := ch.QueueDeclare(
		"hello", // name
		false,   // durable
		false,   // delete when unused
		false,   // exclusive
		false,   // no-wait
		nil,     // arguments
	)


	failOnError(err, "Failed to declare a queue")




	body := reqBodyBytes
	err = ch.Publish(                     //опубликуем сообщение
		"",     // exchange
		q.Name, // routing key
		false,  // mandatory
		false,  // immediate
		amqp.Publishing {
			ContentType: "text/plain",
			Body:       body.Bytes(),
		})
	failOnError(err, "Failed to publish a message")


	msgs, err := ch.Consume("hello","",false,false,false,false,nil)// получим сообщения
	failOnError(err, "Failed to declare a queue")

	fmt.Println("Received a message: %s: ", q.Messages)//засуним кудато сообщения

	go func() {//получим собщения
		for d := range msgs {

			fmt.Println("Received a message: %s\n", d.Body)//засуним кудато сообщения
			d.Ack(true)//отметим как прочитанное
		}
	}()





	//
	//for k, v := range utoGenerated {//вывести  json
	//	if k == "Meta Data"{
	//		continue
	//	}
	//	fmt.Println("key[%s] value[%s]\n", k, v)
	//}

	if err != nil {
		panic(err)
	}

	r.ParseForm() //анализ аргументов ,

	fmt.Println(r.Form)  // ввод информации о форме на стороне сервера
	fmt.Println("path", r.Header)
	fmt.Println("path", r.URL.Path)
	fmt.Println("scheme", r.URL.Scheme)
	fmt.Println(r.Form["url_long"])
	for k, v := range r.Form {
		fmt.Println("key:", k)
		fmt.Println("val:", strings.Join(v, ""))
	}
	fmt.Println("Err", err)
	fmt.Println("Body", Body)




	fmt.Fprintf(w, "<HTML>Hello Maksim!</HTML>") // отправляем данные на клиентскую сторону
}

func main() {
	http.HandleFunc("/", HomeRouterHandler) // установим роутер
	err := http.ListenAndServe(":9000", nil) // задаем слушать порт
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}
